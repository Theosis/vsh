yEd saves diagrams in graphml format, a variant of XML.

The VSH compiler consists of nine simple components, chained linearly
together.  For convenience, all components use the library io.lisp to
read and write "factbases" (see below).

The "runtime" consists of the GRASH interpreter which reads .gsh
scripts and executes the contained commands.

0. Factbase

A factbase is a bag of random facts (similar to Prolog "assertions").

A diagram is represented as a set of facts.  The various components in
the vsh self-compiler can take action based on fact and can add new
facts to the factbase, as more "semantic" information is gleaned.

Each fact (also known as n-triples in semantic web vernacular) consists of
a triple - a predicate, a subject and an object.

A factbase is a file containing such triples, represented in Common
Lisp reader/writer syntax, i.e.

(<pred> <subject> <object>)

where <pred> is typically a symbol[1] or a double-quoted string,

where <subject> is typically an integer (in this version of vsh), and

where <object> is typically a number, string or symbol, or a list of
such items (enclosed in parentheses).

In this implementation, I chose to convert a flat factbase file into
an internal data structure consisting of a hash table of hash tables,
indexed by the <subject> [2].


Components:

1. Scan

The scan component uses the xmls library to read a graphml file and to
converts it into a factbase.

Only items of interest are emitted, and everything else is ignored.

The current implementation emits the following facts:

(node <int>)  declares <int> as the id of a graphical node

(type <id> {"box"|"port"})  declares that id is a box (component) or port

(geometry <id> (x y width height))  declares the geometry for id

(kind <id> "string")  declares the command-line command name for id
    (i.e. the program or script file name in "sh")

(portName <id> "string")  declares the name of the port, currently
    only "in", "out" and "err" are supported port names

(edge <int>)  declares <int> as the id of an edge

(source <id> <sid>)  declares that <sid> is a source port (output,
    err) on edge <id>

(sink <id> <sid>)  declares that <sid> is a sink port (input) on edge
    <id> 

(component "string")  declares the name of the top-level container
    component (i.e. the vsh script)

(quit)  end of input[3], receiving component commits suicide


2. check-input

A simple filter that checks legality of all predicates generated by
the scan component.


3. calc-bounds

Calculates the bounding box for all nodes (components and ports) and
augments the factbase with facts in the form:

(bounds <id> (left top right bottom))


4. mark-directions

Figures out the "direction" (in = sink, out = source) for each port
and augments the factbase with facts in the form:

(source <id>)
(sink <id>)


5. match-ports-to-components

Figures out which ports intersect with which components (and declares
errors if ports are left floating, or intersect with more than one
component), augmenting the factbase with:

(parent <id> <parent-id>)
(input <parent-id> (<id> ...))
(output <parent-id> (<id> ...))


6. assign-pipe-numbers-to-inputs

Allocates a pipe index[4] to every input port.

Creates a top-level fact containing the total number of pipes required
by the script being compiled.

Augments the factbase with:

(n-pipes <top-id> <n>)
(pipe-num <id> <n>)


7. assign-pipe-numbers-to-outputs

FBP dictates that an output port can be wired to only one place, but,
that multiple such outputs can be tied to the same input port.

This component traverses the graph of components and back-fills the
pipe index for each output with the pipe index of the input port that
it is attached to.

Augments the factbase with:

(pipe-num <id> <n>)


8. assign-fds

Assigns FD's to each port.  Special cases: "in" is assigned 0, "out"
is assigned 1, "err" is assigned 2 and beyond that a new fd number is
generated starting at 3 (untested at this time).

Augments factbase with:

(source-fds <id> ((pipe . fd) (pipe . fd) ...))
(sink-fds <id> ((pipe . fd) (pipe . fd) ...))

where "pipe" and "fd" are integers.  The (x . y) notation represents a
pair (2-tuple).


9. emit-grash

Walks the factbase and creates a grash script to fork/exec each
component and to connect the pipes together appropriately.

The factbase is discarded after this step.

Any component that has 0 input ports (sinks) is considered to be a
start of the chain of commands.  These are emitted with the "exec1st"
grash command, which appends the actual command line arguments (to
grash) so that such start components can parse and act on command
line args.  Other components are emitted with the simpler "exec" grash
command. 


10. grash

Grash is a simple interpreter that builds and manipulates an array of
pipes, forks processes, dup2's pipes to join inputs to outputs and
execs components.

Grash is implemented in C to (a) show that more than one language can
be used in this environment and (b) to (possibly superstitiously)
lower the footprint of the inner program that forks itself many times
over. 








[1] A symbol is a single word delimited by whitespace, that may
contain characters such as dash "-" (refer to common lisp syntax
primers).


[2] Many other internal represenatations are possible for a factbase.
A factbase (knowledgebase) could be represented as many hash tables,
keyed by <predicate>, etc.

[3] Although the current vsh self-compiler is implemented to run one
compile cycle, then die, it is possible to build components that live
a long time and interactively interpret incoming data.  In such a
case, it might be convenient to differentiate between a suicide quit
vs. an end of file (process the file, loop back for another).

[4] Grash creates an array of pipes.  Each unique input must be
assigned a unique pipe index in this array.




EXAMPLE.

A simple echo-cat chain consisting of two components "echo hello" and
"cat -" is diagrammed in t1.graphml.

The graphml file is:

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
  <!--Created by yFiles for Java 2.9-->
  <key for="graphml" id="d0" yfiles.type="resources"/>
  <key for="port" id="d1" yfiles.type="portgraphics"/>
  <key for="port" id="d2" yfiles.type="portgeometry"/>
  <key for="port" id="d3" yfiles.type="portuserdata"/>
  <key attr.name="url" attr.type="string" for="node" id="d4"/>
  <key attr.name="description" attr.type="string" for="node" id="d5"/>
  <key for="node" id="d6" yfiles.type="nodegraphics"/>
  <key attr.name="Description" attr.type="string" for="graph" id="d7"/>
  <key attr.name="url" attr.type="string" for="edge" id="d8"/>
  <key attr.name="description" attr.type="string" for="edge" id="d9"/>
  <key for="edge" id="d10" yfiles.type="edgegraphics"/>
  <graph edgedefault="directed" id="G">
    <data key="d7"/>
    <node id="n0">
      <data key="d6">
        <y:GenericNode configuration="BevelNode3">
          <y:Geometry height="76.0" width="131.0" x="250.5" y="104.0"/>
          <y:Fill color="#FF9900" transparent="false"/>
          <y:BorderStyle hasColor="false" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="17.962890625" modelName="custom" textColor="#000000" visible="true" width="63.888671875" x="33.5556640625" y="29.0185546875">echo hello<y:LabelModel>
              <y:SmartNodeLabelModel distance="4.0"/>
            </y:LabelModel>
            <y:ModelParameter>
              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
            </y:ModelParameter>
          </y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n1">
      <data key="d6">
        <y:GenericNode configuration="BevelNode3">
          <y:Geometry height="76.0" width="131.0" x="250.5" y="269.0"/>
          <y:Fill color="#FF9900" transparent="false"/>
          <y:BorderStyle hasColor="false" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="17.962890625" modelName="custom" textColor="#000000" visible="true" width="32.001953125" x="49.4990234375" y="29.0185546875">cat -<y:LabelModel>
              <y:SmartNodeLabelModel distance="4.0"/>
            </y:LabelModel>
            <y:ModelParameter>
              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
            </y:ModelParameter>
          </y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n2">
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="30.0" width="30.0" x="301.0" y="166.0"/>
          <y:Fill color="#FFCC00" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="17.962890625" modelName="custom" textColor="#000000" visible="true" width="23.306640625" x="3.3466796875" y="6.0185546875">out<y:LabelModel>
              <y:SmartNodeLabelModel distance="4.0"/>
            </y:LabelModel>
            <y:ModelParameter>
              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
            </y:ModelParameter>
          </y:NodeLabel>
          <y:Shape type="ellipse"/>
        </y:ShapeNode>
      </data>
    </node>
    <node id="n3">
      <data key="d6">
        <y:ShapeNode>
          <y:Geometry height="30.0" width="30.0" x="301.0" y="256.0"/>
          <y:Fill color="#FFCC00" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="17.962890625" modelName="custom" textColor="#000000" visible="true" width="14.916015625" x="7.5419921875" y="6.0185546875">in<y:LabelModel>
              <y:SmartNodeLabelModel distance="4.0"/>
            </y:LabelModel>
            <y:ModelParameter>
              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
            </y:ModelParameter>
          </y:NodeLabel>
          <y:Shape type="ellipse"/>
        </y:ShapeNode>
      </data>
    </node>
    <edge id="e0" source="n2" target="n3">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="0.0" sy="0.0" tx="0.0" ty="0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:EdgeLabel alignment="center" distance="2.0" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" hasText="false" height="4.0" modelName="custom" preferredPlacement="anywhere" ratio="0.5" textColor="#000000" visible="true" width="4.0" x="-32.0" y="28.0">
            <y:LabelModel>
              <y:SmartEdgeLabelModel autoRotationEnabled="false" defaultAngle="0.0" defaultDistance="10.0"/>
            </y:LabelModel>
            <y:ModelParameter>
              <y:SmartEdgeLabelModelParameter angle="0.0" distance="30.0" distanceToCenter="true" position="right" ratio="0.5" segment="0"/>
            </y:ModelParameter>
          </y:EdgeLabel>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
  </graph>
  <data key="d0">
    <y:Resources/>
  </data>
</graphml>



We can run each component separately from the shell, e.g. 

$ scan t1.graphml > ex2
$ check-input <ex2 >ex3
...

Scan pares the graphml file down to:

(component "t1")
(node n0)
(type n0 box)
(geometry n0 (250.5 104.0 131.0 76.0))
(kind n0 "echo hello")
(node n1)
(type n1 box)
(geometry n1 (250.5 269.0 131.0 76.0))
(kind n1 "cat -")
(node n2)
(type n2 port)
(geometry n2 (301.0 166.0 30.0 30.0))
(portName n2 "out")
(node n3)
(type n3 port)
(geometry n3 (301.0 256.0 30.0 30.0))
(portName n3 "in")
(edge e0)
(source e0 n2)
(sink e0 n3)
(quit)


The input to emit-grash was augmented to (CL is case insensitive,
semi-colons represent to-end-of-line comments):

(COMPONENT "t1")
(N-PIPES "t1" 1)
(NODE N0)
(TYPE N0 BOX)
(GEOMETRY N0 (250.5 104.0 131.0 76.0))
(KIND N0 "echo hello")
(BOUNDS N0 (250.5 104.0 381.5 180.0))
(OUTPUT N0 (N2))
(SOURCE-FDS N0 ((0 . 1)))
(NODE N1)
(TYPE N1 BOX)
(GEOMETRY N1 (250.5 269.0 131.0 76.0))
(KIND N1 "cat -")
(BOUNDS N1 (250.5 269.0 381.5 345.0))
(INPUT N1 (N3))
(SINK-FDS N1 ((0 . 0)))
(NODE N2)
(TYPE N2 PORT)
(GEOMETRY N2 (301.0 166.0 30.0 30.0))
(PORTNAME N2 "out")
(BOUNDS N2 (301.0 166.0 331.0 196.0))
(SOURCE N2)
(PARENT N2 N0)
(PIPE-NUM N2 0)
(FD-NUM N2 1)
(NODE N3)
(TYPE N3 PORT)
(GEOMETRY N3 (301.0 256.0 30.0 30.0))
(PORTNAME N3 "in")
(BOUNDS N3 (301.0 256.0 331.0 286.0))
(SINK N3)
(PARENT N3 N1)
(PIPE-NUM N3 0)
(FD-NUM N3 0)
(EDGE E0)
(SOURCE E0 N2)
(SINK E0 N3)
;;

(quit)

And, finally, the emitted grash script is:

#name t1.gsh
pipes 1
fork
push 1
push 0
dup 1
exec1st echo hello
krof 

fork
push 0
push 0
dup 0
exec cat -
krof 


Translation:

comment with name of script
declare an array of pipes of length 1
fork - parent (grash itself) skips to "krof" line, child executes the next lines
push 1, then 0, then call dup2(pipes[0][1],1), creating FD's
close all pipes
exec "echo hello <command line args if any>"

fork - parent (grash itself) skips to next "krof" line
push 0, then 0, the call dup2(pipes[0][0],0)
close all pipes
exec "cat -"